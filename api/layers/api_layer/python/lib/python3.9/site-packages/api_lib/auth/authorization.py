from enum import Enum
from threading import current_thread

from api_lib.auth.jwt_util import get_decoded_jwt
from api_lib.request.api_request import ApiRequest
from core_lib.data_models.user import user_data_access
from core_lib.services.queue.queue_service import (
    send_message_to_queue,
    get_access_log_queue_url,
)
from core_lib.utils.date_time_util import get_current_utc_datetime_iso
from core_lib.utils.thread_util import safe_get_thread_attribute


class UserGroup(Enum):
    User = "User"
    Admin = "Admin"
    SuperAdmin = "SuperAdmin"


class ActionType(Enum):
    Create = "CREATE"
    List = "LIST"
    Get = "GET"
    Update = "UPDATE"
    Delete = "DELETE"


def is_self_target(target_resource_id, principle):
    return principle == target_resource_id


def is_admin(user_groups):
    return UserGroup.Admin in user_groups or UserGroup.SuperAdmin in user_groups


class TargetResourceAuthorizationModel:
    def __init__(
        self,
        principle: str,
        user_groups: list,
        target_resource_id_holder: dict,
        action_type: ActionType,
    ):
        self.principle = principle
        self.user_groups = user_groups
        self.target_resource_id_holder = target_resource_id_holder
        self.action_type = action_type
        self.target_resource_id = self.get_target_resource_id()

    def get_target_resource_id(self):
        if self.target_resource_id_holder is not None:
            return self.target_resource_id_holder.get("id")

    def is_principle_authorized(self):
        return False

    def format(self):
        return {
            "action_type": self.action_type.value,
            "target_resource_id": self.target_resource_id,
        }


class UserResourceAuthorizationModel(TargetResourceAuthorizationModel):
    def __init__(
        self,
        principle: str,
        user_groups: list,
        target_resource_id_holder: dict,
        action_type: ActionType,
    ):
        super().__init__(principle, user_groups, target_resource_id_holder, action_type)

    def is_principle_authorized(self):
        ACTION_AUTH = {
            ActionType.Create: self.is_create_allowed,
            ActionType.List: self.is_list_allowed,
            ActionType.Get: self.is_get_allowed,
            ActionType.Update: self.is_update_allowed,
            ActionType.Delete: self.is_delete_allowed,
        }

        authorizor = ACTION_AUTH.get(self.action_type)
        return authorizor()

    def is_create_allowed(self):
        return is_admin(user_groups=self.user_groups)

    def is_list_allowed(self):
        return True

    def is_get_allowed(self):
        if is_self_target(
            target_resource_id=self.target_resource_id, principle=self.principle
        ) or is_admin(self.user_groups):
            return True

        associated_resource = next(
            iter(
                user_data_access.query_related_users(
                    user_a_id=self.principle, user_b_id=self.target_resource_id
                )
            ),
            None,
        )

        return associated_resource is not None

    def is_update_allowed(self):
        return is_self_target(
            target_resource_id=self.target_resource_id, principle=self.principle
        ) or is_admin(self.user_groups)

    def is_delete_allowed(self):
        return is_admin(self.user_groups)


class ResourceAccess(Enum):
    AccessUser = UserResourceAuthorizationModel


class Authorization:
    def __init__(
        self,
        resource_access: ResourceAccess,
        action_type: ActionType,
        user_group: UserGroup = None,
    ):
        self.user_group = user_group
        self.resource_access = resource_access
        self.action_type = action_type


def authorize(authorization: Authorization):
    def decorator(func):
        def wrapper(api_request: ApiRequest):
            # Get the JWT from the event
            token = api_request.headers.get("Authorization")
            if not token:
                raise Exception("Authorization header is missing")

            # Decode the JWT and extract the user information
            decoded_jwt = get_decoded_jwt(token)

            user_groups = decoded_jwt["cognito:groups"]

            # Verify that the user is authorized to access the resource
            if (
                authorization.user_group
                and authorization.user_group.value not in user_groups
            ):
                raise Exception("Unauthorized access")

            principle = decoded_jwt["cognito:username"]
            current_thread().__setattr__("principle", principle)
            auth_instance = None
            resource_access = authorization.resource_access
            if resource_access is not None:
                auth_instance = resource_access.value(
                    principle=principle,
                    user_groups=user_groups,
                    target_resource_id_holder=api_request.path_parameters,
                    action_type=authorization.action_type,
                )

                is_authorized = auth_instance.is_principle_authorized()
                if not is_authorized:
                    raise Exception("Unauthorized access")

            message = {
                "utc_datetime_iso": get_current_utc_datetime_iso(),
                "log_type": "access",
                "event_type": "USER_AUTHORIZED",
                "auth_instance": auth_instance.format()
                if auth_instance is not None
                else None,
                "principle": principle,
                "lambda_event": safe_get_thread_attribute("event"),
                "request_headers": api_request.headers,
                "request_body": api_request.body,
                "request_path_parameters": api_request.path_parameters,
            }
            print(message)
            send_message_to_queue(message, get_access_log_queue_url())

            return func(api_request=api_request)

        return wrapper

    return decorator
