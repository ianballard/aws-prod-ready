from api_lib.auth.jwt_util import get_decoded_jwt
from api_lib.request.api_request import ApiRequest
from enum import Enum
from threading import current_thread
from core_lib.services.queue.queue_service import send_message_to_queue, get_access_log_queue_url
from core_lib.utils.thread_util import safe_get_thread_attribute


class UserGroup(Enum):
    User = "User"
    Admin = "Admin"
    SuperAdmin = "SuperAdmin"


class Authorization:

    def __init__(self, user_group: UserGroup):
        self.user_group = user_group


def authorize(authorization: Authorization):
    def decorator(func):
        def wrapper(api_request: ApiRequest):
            # Get the JWT from the event
            token = api_request.headers.get("Authorization")
            if not token:
                raise Exception("Authorization header is missing")

            # Decode the JWT and extract the user information
            decoded_jwt = get_decoded_jwt(token)

            user_groups = decoded_jwt["cognito:groups"]

            # Verify that the user is authorized to access the resource
            if authorization.user_group.value not in user_groups:
                raise Exception("Unauthorized access")

            principle = decoded_jwt["cognito:username"]
            current_thread().__setattr__('principle', principle)

            message = {
                'log_type': 'access',
                'event_type': 'USER_AUTHORIZED',
                'principle': principle,
                'lambda_event': safe_get_thread_attribute('event'),
                'request_headers': api_request.headers,
                'request_body': api_request.body,
                'request_path_parameters': api_request.path_parameters
            }
            print(message)
            send_message_to_queue(message, get_access_log_queue_url())

            return func(
                api_request=api_request
            )

        return wrapper

    return decorator
