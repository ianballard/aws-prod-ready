import time
import os
import jwt
import requests
import base64
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from core_lib.services.auth.impl.cognito_service import (
    get_user_pool_id,
    get_user_pool_client,
)

region = os.environ["region"]
USER_POOL_ID = get_user_pool_id()
USER_POOL_CLIENT = get_user_pool_client()
KNOWN_PUBLIC_KEYS = None


def get_known_public_keys():
    global KNOWN_PUBLIC_KEYS

    if KNOWN_PUBLIC_KEYS is None:
        jwks_url = f"https://cognito-idp.{region}.amazonaws.com/{USER_POOL_ID}/.well-known/jwks.json"
        jwks_response = requests.get(jwks_url)
        jwks = jwks_response.json()
        KNOWN_PUBLIC_KEYS = jwks["keys"]

    return KNOWN_PUBLIC_KEYS


def get_decoded_jwt(token: str, is_access_token=False, check_exp_claim=True):
    jwks = get_known_public_keys()

    # get the kid from the headers prior to verification
    unverified_headers = jwt.get_unverified_header(token)
    kid = unverified_headers["kid"]

    key = None
    for jwk in jwks:
        if jwk["kid"] == kid:
            key = jwk
            break

    public_key_pem = jwk_to_pem(key)

    # Verify the signature of the JWT token using the public key
    verified_token = jwt.decode(
        token,
        public_key_pem,
        algorithms=["RS256"],
        audience=USER_POOL_CLIENT,
        options={"verify_signature": True},
    )

    # additionally we can verify the token expiration
    if check_exp_claim is True and time.time() > verified_token["exp"]:
        return False
    # and the Audience  (use claims['client_id'] if verifying an access token)
    if is_access_token is False and verified_token["aud"] != USER_POOL_CLIENT:
        return False

    if is_access_token is True and verified_token["client_id"] != USER_POOL_CLIENT:
        return False

    return verified_token


def jwk_to_pem(jwk):
    """
    Convert a JWK (JSON Web Key) to PEM (Privacy-Enhanced Mail) format.

    Args:
        jwk (dict): A dictionary containing the JWK data.

    Returns:
        str: The JWK data converted to PEM format.
    """
    # Construct the RSA public key from the JWK
    e = int(base64.urlsafe_b64decode(jwk["e"] + "==").hex(), 16)
    n = int(base64.urlsafe_b64decode(jwk["n"] + "==").hex(), 16)
    public_key = rsa.RSAPublicNumbers(e, n).public_key()

    # Serialize the public key to PEM format
    pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    ).decode("utf-8")
    return pem
