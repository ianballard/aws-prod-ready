import time
import os
import jwt
import requests

from core_lib.services.auth_service import get_user_pool_id

region = os.environ["region"]
USER_POOL_ID = get_user_pool_id()

jwks_url = (
    f"https://cognito-idp.{region}.amazonaws.com/{USER_POOL_ID}/.well-known/jwks.json"
)
# instead of re-downloading the public keys every time
# we download them only on cold start
# https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/
jwks_response = requests.get(jwks_url)
jwks = jwks_response.json()


def get_decoded_jwt(
    token: str, app_client_id: str, is_access_token=False, check_exp_claim=True
):

    # Find the public key that corresponds to the key ID in the JWT header
    public_key = next(filter(lambda x: x['kid'] == jwt.get_unverified_header(token)['kid'], keys), None)

    if not public_key:
        raise ValueError("Public key not found")

    # Verify the signature using the public key
    try:
        jwt_payload = jwt.decode(
            token, public_key, algorithms=["RS256"], options={"verify_exp": False}
        )
    except jwt.InvalidTokenError:
        raise ValueError("Invalid JWT token")

    # since we passed the verification, we can now safely
    # use the unverified claims
    claims = jwt_payload["claims"]
    # additionally we can verify the token expiration
    if check_exp_claim is True and time.time() > claims["exp"]:
        return False
    # and the Audience  (use claims['client_id'] if verifying an access token)
    if is_access_token is False and claims["aud"] != app_client_id:
        return False

    if is_access_token is True and claims["client_id"] != app_client_id:
        return False

    # now we can use the claims
    return claims
