import json

import boto3
from opensearchpy import OpenSearch, RequestsHttpConnection
from requests_aws4auth import AWS4Auth

from core_lib.services.cloud_function import function_service
from core_lib.services.parameter.parameter_service import (
    get_parameter_value,
    ParameterName,
)
from core_lib.services.resource import resource_service
from core_lib.services.secrets import secrets_service
from core_lib.utils import requests_util
from core_lib.utils.log_util import (
    log_info,
    log_unexpected_exception,
    log_function_call,
)
from core_lib.utils.requests_util import TIMEOUT

open_search_boto_client = boto3.client("opensearch")

OPEN_SEARCH_DOMAIN_NAME = None
OPEN_SEARCH_DOMAIN_URL = None
OPEN_SEARCH_CLIENT = None
OPEN_SEARCH_SECRET = None


def get_search_domain_url():
    global OPEN_SEARCH_DOMAIN_URL

    if OPEN_SEARCH_DOMAIN_URL is None:
        OPEN_SEARCH_DOMAIN_URL = get_parameter_value(
            parameter_name=ParameterName.OPEN_SEARCH_DOMAIN_URL
        )

    return OPEN_SEARCH_DOMAIN_URL


def get_search_domain_name():
    global OPEN_SEARCH_DOMAIN_NAME

    if OPEN_SEARCH_DOMAIN_NAME is None:
        OPEN_SEARCH_DOMAIN_NAME = get_parameter_value(
            parameter_name=ParameterName.OPEN_SEARCH_DOMAIN_NAME
        )

    return OPEN_SEARCH_DOMAIN_NAME


def get_open_search_secret():
    global OPEN_SEARCH_SECRET

    if OPEN_SEARCH_SECRET is None:
        secret_value = secrets_service.get_secret_value("opensearch-secret").get(
            "SecretString"
        )
        OPEN_SEARCH_SECRET = json.loads(secret_value)

    return OPEN_SEARCH_SECRET


def get_search_client():
    awsauth = get_es_aws_auth()

    return OpenSearch(
        hosts=[{"host": get_search_domain_url(), "port": 443}],
        http_auth=awsauth,
        use_ssl=True,
        verify_certs=True,
        connection_class=RequestsHttpConnection,
    )


COMMON_SETTINGS = {
    "analysis": {
        "analyzer": {
            "autocomplete_analyzer": {
                "type": "custom",
                "tokenizer": "uax_url_email",
                "filter": ["lowercase", "autocomplete_edge_gram"],
            }
        },
        "filter": {
            "autocomplete_edge_gram": {
                "type": "edge_ngram",
                "min_gram": 3,
                "max_gram": 255,
            }
        },
    }
}

AUTOCOMPLETE_MAPPING = {
    "type": "completion",
    "analyzer": "autocomplete_analyzer",
    "search_analyzer": "autocomplete_analyzer",
}


def get_client_info():
    return get_search_client().info()


@log_function_call
def create_index(index_name: str, index_body: dict):
    return get_search_client().indices.create(index=index_name, body=index_body)


@log_function_call
def upsert(index_name: str, _id: str, doc: dict):
    return get_search_client().update(
        index=index_name, id=_id, body={"doc": doc, "doc_as_upsert": True}
    )


@log_function_call
def search(index_name: str, query: dict):
    return get_search_client().search(index=index_name, body=query)


def is_domain_processing_changes():
    try:
        response = open_search_boto_client.describe_domain(
            DomainName=get_search_domain_name()
        )
        return response["DomainStatus"]["Processing"]
    except Exception as e:
        log_unexpected_exception(e)


def enable_audit_logs():
    try:
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "osd-xsrf": "true",
        }
        config = {
            "compliance": {
                "enabled": True,
                "write_log_diffs": False,
                "read_watched_fields": {},
                "read_ignore_users": [],
                "write_watched_indices": [],
                "write_ignore_users": [],
                "read_metadata_only": True,
                "write_metadata_only": True,
                "external_config": False,
                "internal_config": True,
            },
            "enabled": True,
            "audit": {
                "ignore_users": [],
                "ignore_requests": [],
                "disabled_rest_categories": ["AUTHENTICATED", "GRANTED_PRIVILEGES"],
                "disabled_transport_categories": [
                    "AUTHENTICATED",
                    "GRANTED_PRIVILEGES",
                ],
                "log_request_body": False,
                "resolve_indices": True,
                "resolve_bulk_requests": False,
                "exclude_sensitive_headers": True,
                "enable_transport": False,
                "enable_rest": True,
            },
        }
        url = (
            f"https://{get_search_domain_url()}"
            f"/_dashboards/api/v1/configuration/audit/config"
        )
        awsauth = get_es_aws_auth()

        response = requests_util.post(
            url, headers=headers, data=json.dumps(config), auth=awsauth, timeout=TIMEOUT
        )
        log_info(f"response status_code: {response.status_code}")
        log_info(f"response body: {response.json()}")
    except Exception as e:
        log_unexpected_exception(e)


def get_es_aws_auth():
    session = boto3.Session()
    credentials = session.get_credentials()
    region = session.region_name
    awsauth = AWS4Auth(
        credentials.access_key,
        credentials.secret_key,
        region,
        "es",
        session_token=credentials.token,
    )
    return awsauth


def assign_access(role_name: str, target_function_role_tag_value: str):
    try:
        function_roles = get_lambda_roles_by_function_role_tag(
            target_function_role_tag_value
        )

        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "osd-xsrf": "True",
        }
        mapping = {
            "backend_roles": function_roles,
            "hosts": [],
            "users": function_roles,
        }
        url = (
            f"https://{get_search_domain_url()}"
            f"/_dashboards/api/v1/configuration/rolesmapping/{role_name}"
        )

        awsauth = get_es_aws_auth()

        response = requests_util.post(
            url,
            headers=headers,
            data=json.dumps(mapping),
            auth=awsauth,
            timeout=TIMEOUT,
        )

        log_info(f"response status_code: {response.status_code}")
        log_info(f"response body: {response.json()}")
    except Exception as e:
        log_unexpected_exception(e)


def get_lambda_roles_by_function_role_tag(function_role_tag_value: str):
    function_arns = []
    resource_response = resource_service.get_lambda_resources_by_function_role(
        function_role_tag_value=function_role_tag_value
    )
    function_arns.extend(resource_response.get("resource_arns"))
    while resource_response.get("pagination_token"):
        resource_response = resource_service.get_lambda_resources_by_function_role(
            function_role_tag_value=function_role_tag_value,
            pagination_token=resource_response.get("pagination_token"),
        )
        function_arns.extend(resource_response.get("resource_arns"))
    function_roles = []
    for arn in function_arns:
        function = function_service.get_function(FunctionName=arn)
        role = function.get("Configuration", {}).get("Role")
        function_roles.append(role)
    return function_roles
