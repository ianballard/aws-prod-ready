import base64
import functools
import gzip
import json
import logging
import traceback
import boto3

from core_lib.utils.date_time_util import get_current_utc_datetime_iso
from core_lib.utils.thread_util import safe_get_thread_attribute

logger = logging.getLogger()
logger.setLevel(logging.INFO)

lambda_client = boto3.client("lambda")
logs_client = boto3.client("logs")


# Decorator to log any function call
def log_function_call(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        message = {
            "utc_datetime_iso": get_current_utc_datetime_iso(),
            "log_type": "APP_ACCESS_LOG",
            "event_type": "FUNCTION_CALL",
            "principle": safe_get_thread_attribute("principle"),
            "function": func.__name__,
            "args": args,
            "kwargs": kwargs,
        }
        print(message)
        return func(*args, **kwargs)

    return wrapper


def log_info(message):
    logger.info(message)


def log_warning(message):
    logger.warning(message)


def log_error(message):
    logger.error(message)


def log_exception(message):
    logger.exception(message)


def log_unexpected_exception(e: Exception):
    stack_trace = traceback.format_exc()
    lambda_context = safe_get_thread_attribute("context")
    lambda_context_dict = vars(lambda_context) if lambda_context else None

    if lambda_context_dict is not None:
        lambda_context_dict.pop("client_context", None)
        lambda_context_dict.pop("identity", None)

    message = {
        "utc_datetime_iso": get_current_utc_datetime_iso(),
        "log_type": "APP_ERROR_LOG",
        "event_type": "UNEXPECTED_EXCEPTION",
        "principle": safe_get_thread_attribute("principle"),
        "error_message": str(e),
        "error_stack_trace": stack_trace,
        "lambda_event": safe_get_thread_attribute("event"),
        "lambda_context": lambda_context_dict,
    }
    print(message)


def put_subscription_filters(functions: list, filter_name: str, destination_arn: str, event_filter: str):
    try:
        lambda_client.add_permission(
            FunctionName=destination_arn,
            StatementId="cloudwatch-logs-invoke",
            Action="lambda:InvokeFunction",
            Principal="logs.amazonaws.com",
        )
    except Exception as e:
        log_error(f"error {destination_arn} add_permission")
        if "ResourceConflictException" not in str(e):
            log_unexpected_exception(e)

    for function in functions:
        arn = function.get("arn")
        log = function.get("log")

        if arn == destination_arn:
            continue

        subscription_filters = []
        try:
            subscription_filters = logs_client.describe_subscription_filters(
                logGroupName=log, filterNamePrefix=filter_name, limit=1
            ).get("subscriptionFilters", [])
        except Exception as e:
            log_error(f"error {log} not_found")
            if "ResourceNotFoundException" not in str(e):
                log_unexpected_exception(e)
                continue

        access_log_filter = next(iter(subscription_filters), None)
        if (
            access_log_filter
            and access_log_filter.get("destinationArn:") == destination_arn
        ):
            log_info(f"skipping {log}")
            continue

        try:

            logs_client.put_subscription_filter(
                logGroupName=log,
                filterName=filter_name,
                filterPattern=event_filter,
                destinationArn=destination_arn,
            )
            log_info(f"{log} put_subscription_filter: {filter_name} to {destination_arn}")
        except Exception as e:
            log_error(f"error {log} put_subscription_filter: {filter_name}")
            log_unexpected_exception(e)
            continue


def put_subscription_filters_on_all_lambda_logs(filter_name: str, destination_arn: str, event_filter: str):
    list_functions_response = lambda_client.list_functions()
    next_marker = list_functions_response.get("NextMarker")

    functions = [
        {
            "log": f"/aws/lambda/{function.get('FunctionName')}",
            "arn": function.get("FunctionArn"),
        }
        for function in list_functions_response.get("Functions")
    ]

    put_subscription_filters(
        functions=functions,
        filter_name=filter_name,
        destination_arn=destination_arn,
        event_filter=event_filter
    )

    while next_marker:
        list_functions_response = lambda_client.list_functions(Marker=next_marker)
        functions = [
            {
                "log": f"/aws/lambda/{function.get('FunctionName')}",
                "arn": function.get("FunctionArn"),
            }
            for function in list_functions_response.get("Functions")
        ]
        put_subscription_filters(
            functions=functions,
            filter_name=filter_name,
            destination_arn=destination_arn,
            event_filter=event_filter
        )
        next_marker = list_functions_response.get("NextMarker")


def log_subscribed_log_events(event):
    compressed_data = base64.b64decode(event["awslogs"]["data"])
    decompressed_data = gzip.decompress(compressed_data)

    # Convert the decompressed data to a JSON object
    log_data = json.loads(decompressed_data)

    # Extract log events from the log data
    log_events = log_data["logEvents"]

    # Process each log event
    for log_event in log_events:
        try:
            print(json.loads(json.dumps(log_event.get('message'))))
        except Exception as e:
            log_unexpected_exception(e)