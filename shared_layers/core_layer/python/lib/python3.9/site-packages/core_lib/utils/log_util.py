import base64
import functools
import gzip
import json
import logging
import traceback
import boto3

from core_lib.utils import lambda_util
from core_lib.utils.date_time_util import get_current_utc_datetime_iso
from core_lib.utils.thread_util import safe_get_thread_attribute

logger = logging.getLogger()
logger.setLevel(logging.INFO)

lambda_client = boto3.client("lambda")
logs_client = boto3.client("logs")


# Decorator to log any function call
def log_function_call(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        message = {
            "utc_datetime_iso": get_current_utc_datetime_iso(),
            "log_type": "APP_ACCESS_LOG",
            "event_type": "FUNCTION_CALL",
            "principle": safe_get_thread_attribute("principle"),
            "function": func.__name__,
            "args": args,
            "kwargs": kwargs,
        }
        print(message)
        return func(*args, **kwargs)

    return wrapper


def log_info(message):
    logger.info(message)


def log_warning(message):
    logger.warning(message)


def log_error(message):
    logger.error(message)


def log_exception(message):
    logger.exception(message)


def log_unexpected_exception(e: Exception):
    stack_trace = traceback.format_exc()
    lambda_context = safe_get_thread_attribute("context")
    lambda_context_dict = vars(lambda_context) if lambda_context else None

    if lambda_context_dict is not None:
        lambda_context_dict.pop("client_context", None)
        lambda_context_dict.pop("identity", None)

    message = {
        "utc_datetime_iso": get_current_utc_datetime_iso(),
        "log_type": "APP_ERROR_LOG",
        "event_type": "UNEXPECTED_EXCEPTION",
        "principle": safe_get_thread_attribute("principle"),
        "error_message": str(e),
        "error_stack_trace": stack_trace,
        "lambda_event": safe_get_thread_attribute("event"),
        "lambda_context": lambda_context_dict,
    }
    print(message)


def put_subscription_filters(functions: list, filter_name: str, destination_arn: str, event_filter: str):

    function_resources = [
        {
            "log": f"/aws/lambda/{function.get('FunctionName')}",
            "arn": function.get("FunctionArn"),
        }
        for function in functions
    ]

    lambda_util.add_invoke_permission(
        function_name=destination_arn,
        statement_id="cloudwatch-logs-invoke",
        principle="logs.amazonaws.com"
    )

    for function in function_resources:
        arn = function.get("arn")
        log = function.get("log")

        if arn == destination_arn:
            continue

        subscription_filters = describe_subscription_filters(log_group=log, filter_name=filter_name)
        if subscription_filters is None:
            continue

        access_log_filter = next(iter(subscription_filters), None)
        if (
            access_log_filter
            and access_log_filter.get("destinationArn") == destination_arn
        ):
            continue

        put_subscription_filter(
            log_group=log,
            filter_name=filter_name,
            destination_arn=destination_arn,
            filter_pattern=event_filter
        )


def put_subscription_filters_on_all_lambda_logs(filter_name: str, destination_arn: str, event_filter: str):
    list_functions_response = lambda_client.list_functions()
    next_marker = list_functions_response.get("NextMarker")

    put_subscription_filters(
        functions=list_functions_response.get("Functions"),
        filter_name=filter_name,
        destination_arn=destination_arn,
        event_filter=event_filter
    )

    while next_marker:
        list_functions_response = lambda_client.list_functions(Marker=next_marker)
        put_subscription_filters(
            functions=list_functions_response.get("Functions"),
            filter_name=filter_name,
            destination_arn=destination_arn,
            event_filter=event_filter
        )
        next_marker = list_functions_response.get("NextMarker")


def log_subscribed_log_events(event):
    compressed_data = base64.b64decode(event["awslogs"]["data"])
    decompressed_data = gzip.decompress(compressed_data)

    # Convert the decompressed data to a JSON object
    log_data = json.loads(decompressed_data)

    # Extract log events from the log data
    log_events = log_data["logEvents"]

    # Process each log event
    for log_event in log_events:
        try:
            print(json.loads(json.dumps(log_event.get('message'))))
        except Exception as e:
            log_unexpected_exception(e)


def describe_subscription_filters(log_group: str, filter_name: str):
    try:
        log_info(f"{log_group} describe_subscription_filters: {filter_name}")
        subscription_filters = logs_client.describe_subscription_filters(
            logGroupName=log_group, filterNamePrefix=filter_name, limit=1
        ).get("subscriptionFilters", [])
        return subscription_filters
    except logs_client.exceptions.ResourceNotFoundException as e:
        return
    except Exception as e:
        log_unexpected_exception(e)
        return


def put_subscription_filter(log_group: str, filter_name: str, destination_arn: str, filter_pattern: str):
    try:
        log_info(f"{log_group} put_subscription_filter: {filter_name} to {destination_arn}")
        logs_client.put_subscription_filter(
            logGroupName=log_group,
            filterName=filter_name,
            filterPattern=filter_pattern,
            destinationArn=destination_arn,
        )
    except logs_client.exceptions.ResourceNotFoundException as e:
        return
    except Exception as e:
        log_unexpected_exception(e)
        return
