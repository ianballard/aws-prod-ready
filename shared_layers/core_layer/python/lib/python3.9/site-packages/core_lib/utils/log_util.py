import logging
import json
import traceback
from core_lib.utils.thread_util import safe_get_thread_attribute
from core_lib.services.queue.queue_service import send_message_to_queue, get_error_log_queue_url, get_access_log_queue_url
import functools


logger = logging.getLogger()
logger.setLevel(logging.INFO)


# Decorator to log any function call
def log_function_call(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        message = {
            'log_type': 'access',
            'event_type': 'FUNCTION_CALL',
            'principle': safe_get_thread_attribute('principle'),
            'function': func.__name__,
            'args': args,
            'kwargs': kwargs
        }
        print(message)
        return func(*args, **kwargs)
    return wrapper


def log_info(message):
    logger.info(message)


def log_warning(message):
    logger.warning(message)


def log_error(message):
    logger.error(message)


def log_exception(message):
    logger.exception(message)


def log_unexpected_exception(e: Exception, send_error_to_error_log_queue=True):
    stack_trace = traceback.format_exc()
    lambda_context = safe_get_thread_attribute('context')
    lambda_context_dict = vars(lambda_context) if lambda_context else None

    if lambda_context_dict is not None:
        lambda_context_dict.pop('client_context', None)
        lambda_context_dict.pop('identity', None)

    message = {
        'log_type': 'error',
        'event_type': 'UNEXPECTED_EXCEPTION',
        'principle': safe_get_thread_attribute('principle'),
        'error_message': str(e),
        'error_stack_trace': stack_trace,
        'lambda_event': safe_get_thread_attribute('event'),
        'lambda_context': lambda_context_dict,
    }
    print(message)
    if send_error_to_error_log_queue:
        send_message_to_queue(message, get_error_log_queue_url())
