from datetime import datetime
from unittest.mock import patch

import boto3
import pytest

import core_lib.services.auth.auth_service as auth_service


# Assuming this to be your cognito client, we will stub responses for it
@pytest.fixture
def cognito_client():
    cognito_client = boto3.client("cognito-idp")
    return cognito_client


# Set up some common mock responses
user_response = {
    "User": {
        "Username": "testuser",
        "Attributes": [
            {"Name": "email", "Value": "testuser@example.com"},
            {"Name": "name", "Value": "Test User"},
            # Other user attributes...
        ],
        "UserCreateDate": datetime(2023, 6, 1),
        "UserLastModifiedDate": datetime(2023, 6, 1),
        "Enabled": True,
        "UserStatus": "CONFIRMED",
        # More user details...
    }
}

confirmation_response = {"ResponseMetadata": {"HTTPStatusCode": 200}}

auth_response = {
    "AuthenticationResult": {
        "AccessToken": "access_token_example",
        "ExpiresIn": 3600,
        "TokenType": "Bearer",
        # More auth details...
    },
    "ChallengeParameters": {},
}


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_get_user_pool_id(mock_auth_impl):
    mock_auth_impl.get_user_pool_id.return_value = "test_pool_id"

    # Call the function
    response = auth_service.get_user_pool_id()

    # Assert the function call
    mock_auth_impl.get_user_pool_id.assert_called_once()

    # Assert the response
    assert response == "test_pool_id"


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_get_audience(mock_auth_impl):
    mock_auth_impl.get_user_pool_client.return_value = "test_audience"

    # Call the function
    response = auth_service.get_audience()

    # Assert the function call
    mock_auth_impl.get_user_pool_client.assert_called_once()

    # Assert the response
    assert response == "test_audience"


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_get_known_public_keys(mock_auth_impl):
    mock_auth_impl.get_known_public_keys.return_value = ["test_key"]

    # Call the function
    response = auth_service.get_known_public_keys()

    # Assert the function call
    mock_auth_impl.get_known_public_keys.assert_called_once()

    # Assert the response
    assert response == ["test_key"]


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
@patch("core_lib.services.auth.auth_service.send_message_to_queue")
@patch("core_lib.services.auth.auth_service.get_auth_event_queue_url")
def test_replicated_sign_up(mock_queue_url, mock_send_message, mock_auth_impl):
    mock_auth_impl.sign_up.return_value = user_response
    mock_queue_url.return_value = "mock_queue_url"

    # Call the function with the parameters
    response = auth_service.replicated_sign_up(
        profile="testprofile",
        username="testuser",
        email="testuser@example.com",
        password="testpassword",
        first_name="Test",
        last_name="User",
    )

    # Assert the function call
    mock_auth_impl.sign_up.assert_called_once_with(
        profile="testprofile",
        username="testuser",
        email="testuser@example.com",
        password="testpassword",
        first_name="Test",
        last_name="User",
    )

    # Assert the message was sent to the queue
    mock_send_message.assert_called_with(
        {
            "event_type": "replicated_sign_up",
            "args": {
                "profile": "testprofile",
                "username": "testuser",
                "email": "testuser@example.com",
                "password": "testpassword",
                "first_name": "Test",
                "last_name": "User",
            },
        },
        region=None,  # Adjust based on your setup
        queue_url="mock_queue_url",
    )

    # Assert the response
    assert response == user_response


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
@patch("core_lib.services.auth.auth_service.send_message_to_queue")
@patch("core_lib.services.auth.auth_service.get_auth_event_queue_url")
def test_replicated_confirm_sign_up(mock_queue_url, mock_send_message, mock_auth_impl):
    mock_auth_impl.confirm_sign_up.return_value = confirmation_response
    mock_queue_url.return_value = "mock_queue_url"

    # Call the function with the parameters
    response = auth_service.replicated_confirm_sign_up(
        username="testuser", code="123456"
    )

    # Assert the function call
    mock_auth_impl.confirm_sign_up.assert_called_once_with(
        username="testuser", code="123456"
    )

    # Assert the message was sent to the queue
    mock_send_message.assert_called_with(
        {
            "event_type": "replicated_confirm_sign_up",
            "args": {
                "username": "testuser",
                "code": "123456",
            },
        },
        region=None,  # Adjust based on your setup
        queue_url="mock_queue_url",
    )

    # Assert the response
    assert response == confirmation_response


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_initiate_user_password_auth(mock_auth_impl):
    mock_auth_impl.initiate_user_password_auth.return_value = auth_response

    # Call the function with the parameters
    response = auth_service.initiate_user_password_auth(
        username="testuser", password="testpassword"
    )

    # Assert the function call
    mock_auth_impl.initiate_user_password_auth.assert_called_once_with(
        username="testuser", password="testpassword"
    )

    # Assert the response
    assert response == auth_response


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_admin_create_user(mock_auth_impl):
    mock_auth_impl.admin_create_user.return_value = user_response

    # Call the function with the parameters
    response = auth_service.admin_create_user(
        profile="testprofile",
        username="testuser",
        email="testuser@example.com",
        password="testpassword",
        first_name="Test",
        last_name="User",
        suppress_message=True,
        is_password_permanent=False,
    )

    # Assert the function call
    mock_auth_impl.admin_create_user.assert_called_once_with(
        profile="testprofile",
        username="testuser",
        email="testuser@example.com",
        password="testpassword",
        first_name="Test",
        last_name="User",
        suppress_message=True,
        is_password_permanent=False,
    )

    # Assert the response
    assert response == user_response


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_admin_disable_user(mock_auth_impl):
    mock_auth_impl.admin_disable_user.return_value = confirmation_response

    # Call the function with the parameters
    response = auth_service.admin_disable_user(username="testuser")

    # Assert the function call
    mock_auth_impl.admin_disable_user.assert_called_once_with(username="testuser")

    # Assert the response
    assert response == confirmation_response


@patch("core_lib.services.auth.auth_service.AUTH_SERVICE_IMPL")
def test_health_check(mock_auth_impl):
    mock_auth_impl.health_check.return_value = True

    # Call the function
    response = auth_service.health_check()

    # Assert the function call
    mock_auth_impl.health_check.assert_called_once()

    # Assert the response
    assert response is True
