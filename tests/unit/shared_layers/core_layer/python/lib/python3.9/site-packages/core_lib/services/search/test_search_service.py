import json
from unittest.mock import patch, MagicMock

from opensearchpy import OpenSearch

from core_lib.services.search import search_service
from core_lib.utils.requests_util import TIMEOUT


@patch("core_lib.services.search.impl.open_search_service.get_search_client")
def test_get_search_client(mock_get_search_client):
    mock_get_search_client.return_value = OpenSearch()
    result = search_service.get_search_client()
    assert isinstance(result, OpenSearch)
    mock_get_search_client.assert_called_once()


@patch(
    "core_lib.services.search.impl.open_search_service.is_domain_processing_changes",
    return_value=True,
)
def test_is_domain_processing_changes(mock_is_domain_processing_changes):
    result = search_service.is_domain_processing_changes()
    assert result is True
    mock_is_domain_processing_changes.assert_called_once()


@patch("core_lib.services.search.impl.open_search_service.requests_util.post")
@patch("core_lib.services.search.impl.open_search_service.get_search_domain_url")
@patch("core_lib.services.search.impl.open_search_service.get_es_aws_auth")
def test_enable_audit_logs(mock_get_es_aws_auth, mock_get_search_domain_url, mock_post):
    mock_get_search_domain_url.return_value = "dummy_domain"
    mock_get_es_aws_auth.return_value = "dummy_auth"
    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {"message": "OK"}
    mock_post.return_value = mock_response

    search_service.enable_audit_logs()

    url = "https://dummy_domain/_dashboards/api/v1/configuration/audit/config"
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "osd-xsrf": "true",
    }

    mock_post.assert_called_once_with(
        url,
        headers=headers,
        data=json.dumps(
            {
                "compliance": {
                    "enabled": True,
                    "write_log_diffs": False,
                    "read_watched_fields": {},
                    "read_ignore_users": [],
                    "write_watched_indices": [],
                    "write_ignore_users": [],
                    "read_metadata_only": True,
                    "write_metadata_only": True,
                    "external_config": False,
                    "internal_config": True,
                },
                "enabled": True,
                "audit": {
                    "ignore_users": [],
                    "ignore_requests": [],
                    "disabled_rest_categories": ["AUTHENTICATED", "GRANTED_PRIVILEGES"],
                    "disabled_transport_categories": [
                        "AUTHENTICATED",
                        "GRANTED_PRIVILEGES",
                    ],
                    "log_request_body": False,
                    "resolve_indices": True,
                    "resolve_bulk_requests": False,
                    "exclude_sensitive_headers": True,
                    "enable_transport": False,
                    "enable_rest": True,
                },
            }
        ),
        auth="dummy_auth",
        timeout=TIMEOUT,
    )


@patch("core_lib.services.search.impl.open_search_service.requests_util.post")
@patch("core_lib.services.search.impl.open_search_service.get_search_domain_url")
@patch("core_lib.services.search.impl.open_search_service.get_es_aws_auth")
@patch(
    "core_lib.services.search.impl.open_search_service.get_lambda_roles_by_function_role_tag"
)
def test_assign_access(
    mock_get_lambda_roles, mock_get_es_aws_auth, mock_get_search_domain_url, mock_post
):
    mock_get_search_domain_url.return_value = "dummy_domain"
    mock_get_es_aws_auth.return_value = "dummy_auth"
    mock_get_lambda_roles.return_value = ["dummy_role1", "dummy_role2"]

    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {"message": "OK"}
    mock_post.return_value = mock_response

    role_name = "test_role"
    target_function_role_tag_value = "test_tag_value"
    search_service.assign_access(role_name, target_function_role_tag_value)

    url = (
        f"https://dummy_domain"
        f"/_dashboards/api/v1/configuration/rolesmapping/{role_name}"
    )
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "osd-xsrf": "True",
    }
    mapping = {
        "backend_roles": ["dummy_role1", "dummy_role2"],
        "hosts": [],
        "users": ["dummy_role1", "dummy_role2"],
    }

    mock_post.assert_called_once_with(
        url,
        headers=headers,
        data=json.dumps(mapping),
        auth="dummy_auth",
        timeout=TIMEOUT,
    )


@patch(
    "core_lib.services.search.impl.user_open_search_service.create_user_index",
    return_value=True,
)
def test_create_user_index(mock_create_user_index):
    result = search_service.create_user_index()
    assert result is True
    mock_create_user_index.assert_called_once()
